{"ast":null,"code":"import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nvar _excluded = [\"_blocks\"];\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {boolean} opts.lazy\n*/\n\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  var _super = _createSuper(MaskedPattern);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern); // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\n    @override\n    @param {Object} opts\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                eager: _this.eager,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n        var isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          isInput = false;\n        }\n\n        var def = isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          eager: this.eager,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          eager: this.eager,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFilled;\n      });\n    }\n  }, {\n    key: \"isFixed\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFixed;\n      });\n    }\n  }, {\n    key: \"isOptional\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isOptional;\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var _this$_mapPosToBlock;\n\n      var details = new ChangeDetails();\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        var d = this._blocks[bi]._appendEager();\n\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _flags$_beforeTailSta;\n\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta._blocks[bi]\n        }));\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      if (!this._blocks.length) return 0;\n      var cursor = new PatternCursor(this, cursorPos);\n\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.value.length;\n      } // FORCE is only about a|* otherwise is 0\n\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        } // forward flow\n\n\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled(); // backward flow\n\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos; // cursor.popState();\n        // if (\n        //   cursor.pushRightBeforeInput() &&\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n        //   (!this.lazy || this.extractInput())\n        // ) return cursor.pos;\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"sources":["C:/Users/yulya/Desktop/Новая папка/card/client/node_modules/imask/esm/masked/pattern.js"],"names":["d","_inherits","e","_createSuper","a","_classCallCheck","_","_createClass","g","_get","h","_getPrototypeOf","b","_objectWithoutProperties","i","_set","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","_Masked","_super","opts","arguments","length","undefined","definitions","Object","assign","call","DEFAULTS","key","value","_update","prototype","_rebuildMask","_this","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","blocks","_ret","p","slice","bNames","keys","filter","bName","indexOf","sort","maskedBlock","parent","lazy","eager","placeholderChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","get","map","state","set","maskedState","forEach","bi","reset","every","isComplete","isFilled","isFixed","doCommit","reduce","str","unmaskedValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","_this2","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","_this3","startBlockIter","endBlockIndex","args","bDetails","apply","_value","pos","accVal","_block2","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","name","maskedBlocks","_this4","indices","gi","InputDefinition","FixedDefinition","default"],"mappings":"AAAA,SAASA,CAAC,IAAIC,SAAd,EAAyBC,CAAC,IAAIC,YAA9B,EAA4CC,CAAC,IAAIC,eAAjD,EAAkEC,CAAC,IAAIC,YAAvE,EAAqFC,CAAC,IAAIC,IAA1F,EAAgGC,CAAC,IAAIC,eAArG,EAAsHC,CAAC,IAAIC,wBAA3H,EAAqJC,CAAC,IAAIC,IAA1J,QAAsK,0CAAtK;AACA,SAASC,SAAT,QAA0B,kBAA1B;AACA,OAAOC,aAAP,MAA0B,2BAA1B;AACA,OAAOC,MAAP,MAAmB,WAAnB;AACA,OAAOC,sBAAP,IAAiCC,yBAAjC,QAAkE,+BAAlE;AACA,OAAOC,sBAAP,MAAmC,+BAAnC;AACA,OAAOC,iBAAP,MAA8B,iCAA9B;AACA,OAAOC,aAAP,MAA0B,qBAA1B;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,KAAP,MAAkB,mBAAlB;AACA,OAAO,aAAP;AACA,OAAO,oCAAP;AAEA,IAAIC,SAAS,GAAG,CAAC,SAAD,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,aAAa,GAAG,aAAa,UAAUC,OAAV,EAAmB;AAClD3B,EAAAA,SAAS,CAAC0B,aAAD,EAAgBC,OAAhB,CAAT;;AAEA,MAAIC,MAAM,GAAG1B,YAAY,CAACwB,aAAD,CAAzB;AAEA;;AAEA;;AAEA;;AAEA;;;AACA,WAASA,aAAT,GAAyB;AACvB,QAAIG,IAAI,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;;AAEA1B,IAAAA,eAAe,CAAC,IAAD,EAAOsB,aAAP,CAAf,CAHuB,CAKvB;;;AACAG,IAAAA,IAAI,CAACI,WAAL,GAAmBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBhB,yBAAlB,EAA6CU,IAAI,CAACI,WAAlD,CAAnB;AACA,WAAOL,MAAM,CAACQ,IAAP,CAAY,IAAZ,EAAkBF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBT,aAAa,CAACW,QAAhC,EAA0CR,IAA1C,CAAlB,CAAP;AACD;AACD;AACF;AACA;AACA;;;AAGEvB,EAAAA,YAAY,CAACoB,aAAD,EAAgB,CAAC;AAC3BY,IAAAA,GAAG,EAAE,SADsB;AAE3BC,IAAAA,KAAK,EAAE,SAASC,OAAT,GAAmB;AACxB,UAAIX,IAAI,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AACAD,MAAAA,IAAI,CAACI,WAAL,GAAmBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKF,WAAvB,EAAoCJ,IAAI,CAACI,WAAzC,CAAnB;;AAEAzB,MAAAA,IAAI,CAACE,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,SAA3C,EAAsD,IAAtD,CAAJ,CAAgEL,IAAhE,CAAqE,IAArE,EAA2EP,IAA3E;;AAEA,WAAKa,YAAL;AACD;AACD;;AAV2B,GAAD,EAYzB;AACDJ,IAAAA,GAAG,EAAE,cADJ;AAEDC,IAAAA,KAAK,EAAE,SAASG,YAAT,GAAwB;AAC7B,UAAIC,KAAK,GAAG,IAAZ;;AAEA,UAAIC,IAAI,GAAG,KAAKX,WAAhB;AACA,WAAKY,OAAL,GAAe,EAAf;AACA,WAAKC,MAAL,GAAc,EAAd;AACA,WAAKC,aAAL,GAAqB,EAArB;AACA,UAAIC,OAAO,GAAG,KAAKC,IAAnB;AACA,UAAI,CAACD,OAAD,IAAY,CAACJ,IAAjB,EAAuB;AACvB,UAAIM,cAAc,GAAG,KAArB;AACA,UAAIC,aAAa,GAAG,KAApB;;AAEA,WAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,OAAO,CAACjB,MAA5B,EAAoC,EAAElB,CAAtC,EAAyC;AACvC,YAAI,KAAKuC,MAAT,EAAiB;AACf,cAAIC,IAAI,GAAG,YAAY;AACrB,gBAAIC,CAAC,GAAGN,OAAO,CAACO,KAAR,CAAc1C,CAAd,CAAR;AACA,gBAAI2C,MAAM,GAAGtB,MAAM,CAACuB,IAAP,CAAYd,KAAK,CAACS,MAAlB,EAA0BM,MAA1B,CAAiC,UAAUC,KAAV,EAAiB;AAC7D,qBAAOL,CAAC,CAACM,OAAF,CAAUD,KAAV,MAAqB,CAA5B;AACD,aAFY,CAAb,CAFqB,CAIjB;;AAEJH,YAAAA,MAAM,CAACK,IAAP,CAAY,UAAU1D,CAAV,EAAaQ,CAAb,EAAgB;AAC1B,qBAAOA,CAAC,CAACoB,MAAF,GAAW5B,CAAC,CAAC4B,MAApB;AACD,aAFD,EANqB,CAQjB;;AAEJ,gBAAI4B,KAAK,GAAGH,MAAM,CAAC,CAAD,CAAlB;;AAEA,gBAAIG,KAAJ,EAAW;AACT;AACA,kBAAIG,WAAW,GAAGvC,UAAU,CAACW,MAAM,CAACC,MAAP,CAAc;AACzC4B,gBAAAA,MAAM,EAAEpB,KADiC;AAEzCqB,gBAAAA,IAAI,EAAErB,KAAK,CAACqB,IAF6B;AAGzCC,gBAAAA,KAAK,EAAEtB,KAAK,CAACsB,KAH4B;AAIzCC,gBAAAA,eAAe,EAAEvB,KAAK,CAACuB,eAJkB;AAKzCC,gBAAAA,SAAS,EAAExB,KAAK,CAACwB;AALwB,eAAd,EAM1BxB,KAAK,CAACS,MAAN,CAAaO,KAAb,CAN0B,CAAD,CAA5B;;AAQA,kBAAIG,WAAJ,EAAiB;AACfnB,gBAAAA,KAAK,CAACE,OAAN,CAAcuB,IAAd,CAAmBN,WAAnB,EADe,CACkB;;;AAGjC,oBAAI,CAACnB,KAAK,CAACI,aAAN,CAAoBY,KAApB,CAAL,EAAiChB,KAAK,CAACI,aAAN,CAAoBY,KAApB,IAA6B,EAA7B;;AAEjChB,gBAAAA,KAAK,CAACI,aAAN,CAAoBY,KAApB,EAA2BS,IAA3B,CAAgCzB,KAAK,CAACE,OAAN,CAAcd,MAAd,GAAuB,CAAvD;AACD;;AAEDlB,cAAAA,CAAC,IAAI8C,KAAK,CAAC5B,MAAN,GAAe,CAApB;AACA,qBAAO,UAAP;AACD;AACF,WAlCU,EAAX;;AAoCA,cAAIsB,IAAI,KAAK,UAAb,EAAyB;AAC1B;;AAED,YAAIgB,IAAI,GAAGrB,OAAO,CAACnC,CAAD,CAAlB;AACA,YAAIyD,OAAO,IAAID,IAAI,IAAIzB,IAAZ,CAAX;;AAEA,YAAIyB,IAAI,KAAK3C,aAAa,CAAC6C,SAA3B,EAAsC;AACpC,eAAKzB,MAAL,CAAYsB,IAAZ,CAAiB,KAAKvB,OAAL,CAAad,MAA9B;;AAEA;AACD;;AAED,YAAIsC,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,GAA7B,EAAkC;AAChCnB,UAAAA,cAAc,GAAG,CAACA,cAAlB;AACA;AACD;;AAED,YAAImB,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,GAA7B,EAAkC;AAChClB,UAAAA,aAAa,GAAG,CAACA,aAAjB;AACA;AACD;;AAED,YAAIkB,IAAI,KAAK3C,aAAa,CAAC8C,WAA3B,EAAwC;AACtC,YAAE3D,CAAF;AACAwD,UAAAA,IAAI,GAAGrB,OAAO,CAACnC,CAAD,CAAd;AACA,cAAI,CAACwD,IAAL,EAAW;AACXC,UAAAA,OAAO,GAAG,KAAV;AACD;;AAED,YAAIG,GAAG,GAAGH,OAAO,GAAG,IAAIpD,sBAAJ,CAA2B;AAC7C6C,UAAAA,MAAM,EAAE,IADqC;AAE7CC,UAAAA,IAAI,EAAE,KAAKA,IAFkC;AAG7CC,UAAAA,KAAK,EAAE,KAAKA,KAHiC;AAI7CC,UAAAA,eAAe,EAAE,KAAKA,eAJuB;AAK7CjB,UAAAA,IAAI,EAAEL,IAAI,CAACyB,IAAD,CALmC;AAM7CK,UAAAA,UAAU,EAAEvB;AANiC,SAA3B,CAAH,GAOZ,IAAI/B,sBAAJ,CAA2B;AAC9BiD,UAAAA,IAAI,EAAEA,IADwB;AAE9BJ,UAAAA,KAAK,EAAE,KAAKA,KAFkB;AAG9BU,UAAAA,WAAW,EAAEzB;AAHiB,SAA3B,CAPL;;AAaA,aAAKL,OAAL,CAAauB,IAAb,CAAkBK,GAAlB;AACD;AACF;AACD;AACJ;AACA;;AAnGK,GAZyB,EAiHzB;AACDnC,IAAAA,GAAG,EAAE,OADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO1C,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB3B,IAAI,CAACE,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,OAA3C,EAAoD,IAApD,CAAtB,EAAiF;AACtFI,QAAAA,OAAO,EAAE,KAAKA,OAAL,CAAagC,GAAb,CAAiB,UAAUlE,CAAV,EAAa;AACrC,iBAAOA,CAAC,CAACmE,KAAT;AACD,SAFQ;AAD6E,OAAjF,CAAP;AAKD,KARA;AASDC,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaD,KAAb,EAAoB;AACvB,UAAIjC,OAAO,GAAGiC,KAAK,CAACjC,OAApB;AAAA,UACImC,WAAW,GAAGpE,wBAAwB,CAACkE,KAAD,EAAQrD,SAAR,CAD1C;;AAGA,WAAKoB,OAAL,CAAaoC,OAAb,CAAqB,UAAUtE,CAAV,EAAauE,EAAb,EAAiB;AACpC,eAAOvE,CAAC,CAACmE,KAAF,GAAUjC,OAAO,CAACqC,EAAD,CAAxB;AACD,OAFD;;AAIApE,MAAAA,IAAI,CAACJ,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,OAA3C,EAAoDuC,WAApD,EAAiE,IAAjE,EAAuE,IAAvE,CAAJ;AACD;AACD;AACJ;AACA;;AArBK,GAjHyB,EAwIzB;AACD1C,IAAAA,GAAG,EAAE,OADJ;AAEDC,IAAAA,KAAK,EAAE,SAAS4C,KAAT,GAAiB;AACtB3E,MAAAA,IAAI,CAACE,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,OAA3C,EAAoD,IAApD,CAAJ,CAA8DL,IAA9D,CAAmE,IAAnE;;AAEA,WAAKS,OAAL,CAAaoC,OAAb,CAAqB,UAAUtE,CAAV,EAAa;AAChC,eAAOA,CAAC,CAACwE,KAAF,EAAP;AACD,OAFD;AAGD;AACD;AACJ;AACA;;AAXK,GAxIyB,EAqJzB;AACD7C,IAAAA,GAAG,EAAE,YADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/B,OAAL,CAAauC,KAAb,CAAmB,UAAUzE,CAAV,EAAa;AACrC,eAAOA,CAAC,CAAC0E,UAAT;AACD,OAFM,CAAP;AAGD;AACD;AACJ;AACA;;AATK,GArJyB,EAgKzB;AACD/C,IAAAA,GAAG,EAAE,UADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/B,OAAL,CAAauC,KAAb,CAAmB,UAAUzE,CAAV,EAAa;AACrC,eAAOA,CAAC,CAAC2E,QAAT;AACD,OAFM,CAAP;AAGD;AANA,GAhKyB,EAuKzB;AACDhD,IAAAA,GAAG,EAAE,SADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/B,OAAL,CAAauC,KAAb,CAAmB,UAAUzE,CAAV,EAAa;AACrC,eAAOA,CAAC,CAAC4E,OAAT;AACD,OAFM,CAAP;AAGD;AANA,GAvKyB,EA8KzB;AACDjD,IAAAA,GAAG,EAAE,YADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/B,OAAL,CAAauC,KAAb,CAAmB,UAAUzE,CAAV,EAAa;AACrC,eAAOA,CAAC,CAAC+D,UAAT;AACD,OAFM,CAAP;AAGD;AACD;AACJ;AACA;;AATK,GA9KyB,EAyLzB;AACDpC,IAAAA,GAAG,EAAE,UADJ;AAEDC,IAAAA,KAAK,EAAE,SAASiD,QAAT,GAAoB;AACzB,WAAK3C,OAAL,CAAaoC,OAAb,CAAqB,UAAUtE,CAAV,EAAa;AAChC,eAAOA,CAAC,CAAC6E,QAAF,EAAP;AACD,OAFD;;AAIAhF,MAAAA,IAAI,CAACE,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,UAA3C,EAAuD,IAAvD,CAAJ,CAAiEL,IAAjE,CAAsE,IAAtE;AACD;AACD;AACJ;AACA;;AAXK,GAzLyB,EAsMzB;AACDE,IAAAA,GAAG,EAAE,eADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAK/B,OAAL,CAAa4C,MAAb,CAAoB,UAAUC,GAAV,EAAe/E,CAAf,EAAkB;AAC3C,eAAO+E,GAAG,IAAI/E,CAAC,CAACgF,aAAhB;AACD,OAFM,EAEJ,EAFI,CAAP;AAGD,KANA;AAODZ,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaY,aAAb,EAA4B;AAC/B7E,MAAAA,IAAI,CAACJ,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,eAA3C,EAA4DkD,aAA5D,EAA2E,IAA3E,EAAiF,IAAjF,CAAJ;AACD;AACD;AACJ;AACA;;AAZK,GAtMyB,EAoNzB;AACDrD,IAAAA,GAAG,EAAE,OADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB;AACA,aAAO,KAAK/B,OAAL,CAAa4C,MAAb,CAAoB,UAAUC,GAAV,EAAe/E,CAAf,EAAkB;AAC3C,eAAO+E,GAAG,IAAI/E,CAAC,CAAC4B,KAAhB;AACD,OAFM,EAEJ,EAFI,CAAP;AAGD,KAPA;AAQDwC,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaxC,KAAb,EAAoB;AACvBzB,MAAAA,IAAI,CAACJ,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,OAA3C,EAAoDF,KAApD,EAA2D,IAA3D,EAAiE,IAAjE,CAAJ;AACD;AACD;AACJ;AACA;;AAbK,GApNyB,EAmOzB;AACDD,IAAAA,GAAG,EAAE,YADJ;AAEDC,IAAAA,KAAK,EAAE,SAASqD,UAAT,CAAoBC,IAApB,EAA0B;AAC/B,aAAOrF,IAAI,CAACE,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,YAA3C,EAAyD,IAAzD,CAAJ,CAAmEL,IAAnE,CAAwE,IAAxE,EAA8EyD,IAA9E,EAAoFC,SAApF,CAA8F,KAAKC,kBAAL,EAA9F,CAAP;AACD;AACD;AACJ;AACA;;AAPK,GAnOyB,EA4OzB;AACDzD,IAAAA,GAAG,EAAE,cADJ;AAEDC,IAAAA,KAAK,EAAE,SAASyD,YAAT,GAAwB;AAC7B,UAAIC,oBAAJ;;AAEA,UAAIC,OAAO,GAAG,IAAIlF,aAAJ,EAAd;AACA,UAAImF,eAAe,GAAG,CAACF,oBAAoB,GAAG,KAAKG,cAAL,CAAoB,KAAK7D,KAAL,CAAWR,MAA/B,CAAxB,MAAoE,IAApE,IAA4EkE,oBAAoB,KAAK,KAAK,CAA1G,GAA8G,KAAK,CAAnH,GAAuHA,oBAAoB,CAACI,KAAlK;AACA,UAAIF,eAAe,IAAI,IAAvB,EAA6B,OAAOD,OAAP,CALA,CAKgB;;AAE7C,UAAI,KAAKrD,OAAL,CAAasD,eAAb,EAA8Bb,QAAlC,EAA4C,EAAEa,eAAF;;AAE5C,WAAK,IAAIjB,EAAE,GAAGiB,eAAd,EAA+BjB,EAAE,GAAG,KAAKrC,OAAL,CAAad,MAAjD,EAAyD,EAAEmD,EAA3D,EAA+D;AAC7D,YAAInF,CAAC,GAAG,KAAK8C,OAAL,CAAaqC,EAAb,EAAiBc,YAAjB,EAAR;;AAEA,YAAI,CAACjG,CAAC,CAACuG,QAAP,EAAiB;AACjBJ,QAAAA,OAAO,CAACJ,SAAR,CAAkB/F,CAAlB;AACD;;AAED,aAAOmG,OAAP;AACD;AACD;AACJ;AACA;;AAtBK,GA5OyB,EAoQzB;AACD5D,IAAAA,GAAG,EAAE,gBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASgE,cAAT,CAAwBC,EAAxB,EAA4B;AACjC,UAAIC,KAAK,GAAG3E,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;;AAEA,UAAI4E,SAAS,GAAG,KAAKN,cAAL,CAAoB,KAAK7D,KAAL,CAAWR,MAA/B,CAAhB;;AAEA,UAAImE,OAAO,GAAG,IAAIlF,aAAJ,EAAd;AACA,UAAI,CAAC0F,SAAL,EAAgB,OAAOR,OAAP;;AAEhB,WAAK,IAAIhB,EAAE,GAAGwB,SAAS,CAACL,KAAxB,GAAgC,EAAEnB,EAAlC,EAAsC;AACpC,YAAIyB,qBAAJ;;AAEA,YAAIC,MAAM,GAAG,KAAK/D,OAAL,CAAaqC,EAAb,CAAb;AACA,YAAI,CAAC0B,MAAL,EAAa;;AAEb,YAAIC,YAAY,GAAGD,MAAM,CAACE,WAAP,CAAmBN,EAAnB,EAAuBtE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBsE,KAAlB,EAAyB;AACjEM,UAAAA,gBAAgB,EAAE,CAACJ,qBAAqB,GAAGF,KAAK,CAACM,gBAA/B,MAAqD,IAArD,IAA6DJ,qBAAqB,KAAK,KAAK,CAA5F,GAAgG,KAAK,CAArG,GAAyGA,qBAAqB,CAAC9D,OAAtB,CAA8BqC,EAA9B;AAD1D,SAAzB,CAAvB,CAAnB;;AAIA,YAAI8B,IAAI,GAAGH,YAAY,CAACG,IAAxB;AACAd,QAAAA,OAAO,CAACJ,SAAR,CAAkBe,YAAlB;AACA,YAAIG,IAAI,IAAIH,YAAY,CAACI,WAAzB,EAAsC,MAZF,CAYS;AAC9C;;AAED,aAAOf,OAAP;AACD;AACD;AACJ;AACA;;AA7BK,GApQyB,EAmSzB;AACD5D,IAAAA,GAAG,EAAE,aADJ;AAEDC,IAAAA,KAAK,EAAE,SAAS2E,WAAT,GAAuB;AAC5B,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAIC,OAAO,GAAGtF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,UAAIuF,KAAK,GAAGvF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKS,KAAL,CAAWR,MAA3F;AACA,UAAIuF,SAAS,GAAG,IAAIjG,iBAAJ,EAAhB;AACA,UAAI+F,OAAO,KAAKC,KAAhB,EAAuB,OAAOC,SAAP;;AAEvB,WAAKC,qBAAL,CAA2BH,OAA3B,EAAoCC,KAApC,EAA2C,UAAU1G,CAAV,EAAauE,EAAb,EAAiBsC,QAAjB,EAA2BC,MAA3B,EAAmC;AAC5E,YAAIC,UAAU,GAAG/G,CAAC,CAACuG,WAAF,CAAcM,QAAd,EAAwBC,MAAxB,CAAjB;AACAC,QAAAA,UAAU,CAACC,IAAX,GAAkBR,MAAM,CAACS,eAAP,CAAuB1C,EAAvB,CAAlB;AACAwC,QAAAA,UAAU,CAACG,IAAX,GAAkBV,MAAM,CAACW,cAAP,CAAsB5C,EAAtB,CAAlB;AACA,YAAIwC,UAAU,YAAYrG,iBAA1B,EAA6CqG,UAAU,CAACK,UAAX,GAAwB7C,EAAxB;AAC7CoC,QAAAA,SAAS,CAACU,MAAV,CAAiBN,UAAjB;AACD,OAND;;AAQA,aAAOJ,SAAP;AACD;AACD;AACJ;AACA;;AAtBK,GAnSyB,EA2TzB;AACDhF,IAAAA,GAAG,EAAE,cADJ;AAEDC,IAAAA,KAAK,EAAE,SAAS0F,YAAT,GAAwB;AAC7B,UAAIb,OAAO,GAAGtF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,UAAIuF,KAAK,GAAGvF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKS,KAAL,CAAWR,MAA3F;AACA,UAAI0E,KAAK,GAAG3E,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AACA,UAAIsF,OAAO,KAAKC,KAAhB,EAAuB,OAAO,EAAP;AACvB,UAAIa,KAAK,GAAG,EAAZ;;AAEA,WAAKX,qBAAL,CAA2BH,OAA3B,EAAoCC,KAApC,EAA2C,UAAU1G,CAAV,EAAaN,CAAb,EAAgB+G,OAAhB,EAAyBC,KAAzB,EAAgC;AACzEa,QAAAA,KAAK,IAAIvH,CAAC,CAACsH,YAAF,CAAeb,OAAf,EAAwBC,KAAxB,EAA+BZ,KAA/B,CAAT;AACD,OAFD;;AAIA,aAAOyB,KAAP;AACD;AAdA,GA3TyB,EA0UzB;AACD5F,IAAAA,GAAG,EAAE,iBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASqF,eAAT,CAAyBG,UAAzB,EAAqC;AAC1C,UAAII,UAAJ;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,KAAKtF,MAAL,CAAYf,MAAlC,EAA0C,EAAEqG,EAA5C,EAAgD;AAC9C,YAAIT,IAAI,GAAG,KAAK7E,MAAL,CAAYsF,EAAZ,CAAX;AACA,YAAIT,IAAI,IAAII,UAAZ,EAAwBI,UAAU,GAAGR,IAAb,CAAxB,KAA+C;AAChD;;AAED,aAAOQ,UAAP;AACD;AACD;;AAZC,GA1UyB,EAwVzB;AACD7F,IAAAA,GAAG,EAAE,oBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASwD,kBAAT,CAA4BsC,YAA5B,EAA0C;AAC/C,UAAIC,MAAM,GAAG,IAAb;;AAEA,UAAIpC,OAAO,GAAG,IAAIlF,aAAJ,EAAd;AACA,UAAI,KAAKgD,IAAL,IAAaqE,YAAY,IAAI,IAAjC,EAAuC,OAAOnC,OAAP;;AAEvC,UAAIqC,cAAc,GAAG,KAAKnC,cAAL,CAAoB,KAAK7D,KAAL,CAAWR,MAA/B,CAArB;;AAEA,UAAI,CAACwG,cAAL,EAAqB,OAAOrC,OAAP;AACrB,UAAIC,eAAe,GAAGoC,cAAc,CAAClC,KAArC;AACA,UAAImC,aAAa,GAAGH,YAAY,IAAI,IAAhB,GAAuBA,YAAvB,GAAsC,KAAKxF,OAAL,CAAad,MAAvE;;AAEA,WAAKc,OAAL,CAAaU,KAAb,CAAmB4C,eAAnB,EAAoCqC,aAApC,EAAmDvD,OAAnD,CAA2D,UAAUtE,CAAV,EAAa;AACtE,YAAI,CAACA,CAAC,CAACqD,IAAH,IAAWqE,YAAY,IAAI,IAA/B,EAAqC;AACnC;AACA,cAAII,IAAI,GAAG9H,CAAC,CAACkC,OAAF,IAAa,IAAb,GAAoB,CAAClC,CAAC,CAACkC,OAAF,CAAUd,MAAX,CAApB,GAAyC,EAApD;;AAEA,cAAI2G,QAAQ,GAAG/H,CAAC,CAACoF,kBAAF,CAAqB4C,KAArB,CAA2BhI,CAA3B,EAA8B8H,IAA9B,CAAf;;AAEAH,UAAAA,MAAM,CAACM,MAAP,IAAiBF,QAAQ,CAACpC,QAA1B;AACAJ,UAAAA,OAAO,CAACJ,SAAR,CAAkB4C,QAAlB;AACD;AACF,OAVD;;AAYA,aAAOxC,OAAP;AACD;AACD;;AA5BC,GAxVyB,EAsXzB;AACD5D,IAAAA,GAAG,EAAE,gBADJ;AAEDC,IAAAA,KAAK,EAAE,SAAS6D,cAAT,CAAwByC,GAAxB,EAA6B;AAClC,UAAIC,MAAM,GAAG,EAAb;;AAEA,WAAK,IAAI5D,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,KAAKrC,OAAL,CAAad,MAAnC,EAA2C,EAAEmD,EAA7C,EAAiD;AAC/C,YAAI6D,OAAO,GAAG,KAAKlG,OAAL,CAAaqC,EAAb,CAAd;AACA,YAAI8D,aAAa,GAAGF,MAAM,CAAC/G,MAA3B;AACA+G,QAAAA,MAAM,IAAIC,OAAO,CAACxG,KAAlB;;AAEA,YAAIsG,GAAG,IAAIC,MAAM,CAAC/G,MAAlB,EAA0B;AACxB,iBAAO;AACLsE,YAAAA,KAAK,EAAEnB,EADF;AAEL+D,YAAAA,MAAM,EAAEJ,GAAG,GAAGG;AAFT,WAAP;AAID;AACF;AACF;AACD;;AAlBC,GAtXyB,EA0YzB;AACD1G,IAAAA,GAAG,EAAE,gBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASuF,cAAT,CAAwBC,UAAxB,EAAoC;AACzC,aAAO,KAAKlF,OAAL,CAAaU,KAAb,CAAmB,CAAnB,EAAsBwE,UAAtB,EAAkCtC,MAAlC,CAAyC,UAAUoD,GAAV,EAAelI,CAAf,EAAkB;AAChE,eAAOkI,GAAG,IAAIlI,CAAC,CAAC4B,KAAF,CAAQR,MAAtB;AACD,OAFM,EAEJ,CAFI,CAAP;AAGD;AACD;;AAPC,GA1YyB,EAmZzB;AACDO,IAAAA,GAAG,EAAE,uBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASgF,qBAAT,CAA+BH,OAA/B,EAAwC;AAC7C,UAAIC,KAAK,GAAGvF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKS,KAAL,CAAWR,MAA3F;AACA,UAAImH,EAAE,GAAGpH,SAAS,CAACC,MAAV,GAAmB,CAAnB,GAAuBD,SAAS,CAAC,CAAD,CAAhC,GAAsCE,SAA/C;;AAEA,UAAImH,aAAa,GAAG,KAAK/C,cAAL,CAAoBgB,OAApB,CAApB;;AAEA,UAAI+B,aAAJ,EAAmB;AACjB,YAAIC,WAAW,GAAG,KAAKhD,cAAL,CAAoBiB,KAApB,CAAlB,CADiB,CAC6B;;;AAG9C,YAAIgC,WAAW,GAAGD,WAAW,IAAID,aAAa,CAAC9C,KAAd,KAAwB+C,WAAW,CAAC/C,KAArE;AACA,YAAIiD,iBAAiB,GAAGH,aAAa,CAACF,MAAtC;AACA,YAAIM,eAAe,GAAGH,WAAW,IAAIC,WAAf,GAA6BD,WAAW,CAACH,MAAzC,GAAkD,KAAKpG,OAAL,CAAasG,aAAa,CAAC9C,KAA3B,EAAkC9D,KAAlC,CAAwCR,MAAhH;AACAmH,QAAAA,EAAE,CAAC,KAAKrG,OAAL,CAAasG,aAAa,CAAC9C,KAA3B,CAAD,EAAoC8C,aAAa,CAAC9C,KAAlD,EAAyDiD,iBAAzD,EAA4EC,eAA5E,CAAF;;AAEA,YAAIH,WAAW,IAAI,CAACC,WAApB,EAAiC;AAC/B;AACA,eAAK,IAAInE,EAAE,GAAGiE,aAAa,CAAC9C,KAAd,GAAsB,CAApC,EAAuCnB,EAAE,GAAGkE,WAAW,CAAC/C,KAAxD,EAA+D,EAAEnB,EAAjE,EAAqE;AACnEgE,YAAAA,EAAE,CAAC,KAAKrG,OAAL,CAAaqC,EAAb,CAAD,EAAmBA,EAAnB,EAAuB,CAAvB,EAA0B,KAAKrC,OAAL,CAAaqC,EAAb,EAAiB3C,KAAjB,CAAuBR,MAAjD,CAAF;AACD,WAJ8B,CAI7B;;;AAGFmH,UAAAA,EAAE,CAAC,KAAKrG,OAAL,CAAauG,WAAW,CAAC/C,KAAzB,CAAD,EAAkC+C,WAAW,CAAC/C,KAA9C,EAAqD,CAArD,EAAwD+C,WAAW,CAACH,MAApE,CAAF;AACD;AACF;AACF;AACD;AACJ;AACA;;AA9BK,GAnZyB,EAmbzB;AACD3G,IAAAA,GAAG,EAAE,QADJ;AAEDC,IAAAA,KAAK,EAAE,SAASiH,MAAT,GAAkB;AACvB,UAAIpC,OAAO,GAAGtF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAlF;AACA,UAAIuF,KAAK,GAAGvF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAKS,KAAL,CAAWR,MAA3F;;AAEA,UAAI0H,aAAa,GAAGjJ,IAAI,CAACE,eAAe,CAACgB,aAAa,CAACe,SAAf,CAAhB,EAA2C,QAA3C,EAAqD,IAArD,CAAJ,CAA+DL,IAA/D,CAAoE,IAApE,EAA0EgF,OAA1E,EAAmFC,KAAnF,CAApB;;AAEA,WAAKE,qBAAL,CAA2BH,OAA3B,EAAoCC,KAApC,EAA2C,UAAU1G,CAAV,EAAaN,CAAb,EAAgBmH,QAAhB,EAA0BC,MAA1B,EAAkC;AAC3EgC,QAAAA,aAAa,CAAC3D,SAAd,CAAwBnF,CAAC,CAAC6I,MAAF,CAAShC,QAAT,EAAmBC,MAAnB,CAAxB;AACD,OAFD;;AAIA,aAAOgC,aAAP;AACD;AACD;AACJ;AACA;;AAhBK,GAnbyB,EAqczB;AACDnH,IAAAA,GAAG,EAAE,iBADJ;AAEDC,IAAAA,KAAK,EAAE,SAASmH,eAAT,CAAyBC,SAAzB,EAAoC;AACzC,UAAIC,SAAS,GAAG9H,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoEf,SAAS,CAAC8I,IAA9F;AACA,UAAI,CAAC,KAAKhH,OAAL,CAAad,MAAlB,EAA0B,OAAO,CAAP;AAC1B,UAAI+H,MAAM,GAAG,IAAIxI,aAAJ,CAAkB,IAAlB,EAAwBqI,SAAxB,CAAb;;AAEA,UAAIC,SAAS,KAAK7I,SAAS,CAAC8I,IAA5B,EAAkC;AAChC;AACA;AACA;AACA,YAAIC,MAAM,CAACC,oBAAP,EAAJ,EAAmC,OAAOD,MAAM,CAACjB,GAAd;AACnCiB,QAAAA,MAAM,CAACE,QAAP;AACA,YAAIF,MAAM,CAACG,mBAAP,EAAJ,EAAkC,OAAOH,MAAM,CAACjB,GAAd;AAClC,eAAO,KAAKtG,KAAL,CAAWR,MAAlB;AACD,OAbwC,CAavC;;;AAGF,UAAI6H,SAAS,KAAK7I,SAAS,CAACmJ,IAAxB,IAAgCN,SAAS,KAAK7I,SAAS,CAACoJ,UAA5D,EAAwE;AACtE;AACA,YAAIP,SAAS,KAAK7I,SAAS,CAACmJ,IAA5B,EAAkC;AAChCJ,UAAAA,MAAM,CAACM,qBAAP;AACA,cAAIN,MAAM,CAACO,EAAP,IAAaP,MAAM,CAACjB,GAAP,KAAec,SAAhC,EAA2C,OAAOA,SAAP;AAC3CG,UAAAA,MAAM,CAACE,QAAP;AACD,SANqE,CAMpE;;;AAGFF,QAAAA,MAAM,CAACG,mBAAP;AACAH,QAAAA,MAAM,CAACQ,sBAAP;AACAR,QAAAA,MAAM,CAACS,oBAAP,GAXsE,CAWvC;;AAE/B,YAAIX,SAAS,KAAK7I,SAAS,CAACmJ,IAA5B,EAAkC;AAChCJ,UAAAA,MAAM,CAACC,oBAAP;AACAD,UAAAA,MAAM,CAACU,uBAAP;AACA,cAAIV,MAAM,CAACO,EAAP,IAAaP,MAAM,CAACjB,GAAP,IAAcc,SAA/B,EAA0C,OAAOG,MAAM,CAACjB,GAAd;AAC1CiB,UAAAA,MAAM,CAACE,QAAP;AACA,cAAIF,MAAM,CAACO,EAAP,IAAaP,MAAM,CAACjB,GAAP,IAAcc,SAA/B,EAA0C,OAAOG,MAAM,CAACjB,GAAd;AAC1CiB,UAAAA,MAAM,CAACE,QAAP;AACD;;AAED,YAAIF,MAAM,CAACO,EAAX,EAAe,OAAOP,MAAM,CAACjB,GAAd;AACf,YAAIe,SAAS,KAAK7I,SAAS,CAACoJ,UAA5B,EAAwC,OAAO,CAAP;AACxCL,QAAAA,MAAM,CAACE,QAAP;AACA,YAAIF,MAAM,CAACO,EAAX,EAAe,OAAOP,MAAM,CAACjB,GAAd;AACfiB,QAAAA,MAAM,CAACE,QAAP;AACA,YAAIF,MAAM,CAACO,EAAX,EAAe,OAAOP,MAAM,CAACjB,GAAd,CA3BuD,CA2BpC;AAClC;AACA;AACA;AACA;AACA;;AAEA,eAAO,CAAP;AACD;;AAED,UAAIe,SAAS,KAAK7I,SAAS,CAAC0J,KAAxB,IAAiCb,SAAS,KAAK7I,SAAS,CAAC2J,WAA7D,EAA0E;AACxE;AACAZ,QAAAA,MAAM,CAACC,oBAAP;AACAD,QAAAA,MAAM,CAACU,uBAAP;AACA,YAAIV,MAAM,CAACM,qBAAP,EAAJ,EAAoC,OAAON,MAAM,CAACjB,GAAd;AACpC,YAAIe,SAAS,KAAK7I,SAAS,CAAC2J,WAA5B,EAAyC,OAAO,KAAKnI,KAAL,CAAWR,MAAlB,CAL+B,CAKL;;AAEnE+H,QAAAA,MAAM,CAACE,QAAP;AACA,YAAIF,MAAM,CAACO,EAAX,EAAe,OAAOP,MAAM,CAACjB,GAAd;AACfiB,QAAAA,MAAM,CAACE,QAAP;AACA,YAAIF,MAAM,CAACO,EAAX,EAAe,OAAOP,MAAM,CAACjB,GAAd;AACf,eAAO,KAAKa,eAAL,CAAqBC,SAArB,EAAgC5I,SAAS,CAACmJ,IAA1C,CAAP;AACD;;AAED,aAAOP,SAAP;AACD;AACD;;AAvEC,GArcyB,EA8gBzB;AACDrH,IAAAA,GAAG,EAAE,aADJ;AAEDC,IAAAA,KAAK,EAAE,SAASuB,WAAT,CAAqB6G,IAArB,EAA2B;AAChC,aAAO,KAAKC,YAAL,CAAkBD,IAAlB,EAAwB,CAAxB,CAAP;AACD;AACD;;AALC,GA9gByB,EAqhBzB;AACDrI,IAAAA,GAAG,EAAE,cADJ;AAEDC,IAAAA,KAAK,EAAE,SAASqI,YAAT,CAAsBD,IAAtB,EAA4B;AACjC,UAAIE,MAAM,GAAG,IAAb;;AAEA,UAAIC,OAAO,GAAG,KAAK/H,aAAL,CAAmB4H,IAAnB,CAAd;AACA,UAAI,CAACG,OAAL,EAAc,OAAO,EAAP;AACd,aAAOA,OAAO,CAACjG,GAAR,CAAY,UAAUkG,EAAV,EAAc;AAC/B,eAAOF,MAAM,CAAChI,OAAP,CAAekI,EAAf,CAAP;AACD,OAFM,CAAP;AAGD;AAVA,GArhByB,CAAhB,CAAZ;;AAkiBA,SAAOrJ,aAAP;AACD,CA9jBgC,CA8jB/BT,MA9jB+B,CAAjC;;AA+jBAS,aAAa,CAACW,QAAd,GAAyB;AACvB2B,EAAAA,IAAI,EAAE,IADiB;AAEvBE,EAAAA,eAAe,EAAE;AAFM,CAAzB;AAIAxC,aAAa,CAAC6C,SAAd,GAA0B,GAA1B;AACA7C,aAAa,CAAC8C,WAAd,GAA4B,IAA5B;AACA9C,aAAa,CAACsJ,eAAd,GAAgC9J,sBAAhC;AACAQ,aAAa,CAACuJ,eAAd,GAAgC7J,sBAAhC;AACAI,KAAK,CAACE,aAAN,GAAsBA,aAAtB;AAEA,SAASA,aAAa,IAAIwJ,OAA1B","sourcesContent":["import { d as _inherits, e as _createSuper, a as _classCallCheck, _ as _createClass, g as _get, h as _getPrototypeOf, b as _objectWithoutProperties, i as _set } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nvar _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {boolean} opts.lazy\n*/\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  var _super = _createSuper(MaskedPattern);\n\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern);\n\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n  /**\n    @override\n    @param {Object} opts\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              // $FlowFixMe no ideas\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                eager: _this.eager,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n        var isInput = (char in defs);\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          isInput = false;\n        }\n\n        var def = isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          eager: this.eager,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          eager: this.eager,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, _excluded);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFilled;\n      });\n    }\n  }, {\n    key: \"isFixed\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isFixed;\n      });\n    }\n  }, {\n    key: \"isOptional\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isOptional;\n      });\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      var _this$_mapPosToBlock;\n\n      var details = new ChangeDetails();\n      var startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n      for (var bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        var d = this._blocks[bi]._appendEager();\n\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _flags$_beforeTailSta;\n\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, Object.assign({}, flags, {\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta._blocks[bi]\n        }));\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\n      @override\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      if (!this._blocks.length) return 0;\n      var cursor = new PatternCursor(this, cursorPos);\n\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.value.length;\n      } // FORCE is only about a|* otherwise is 0\n\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        } // forward flow\n\n\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled(); // backward flow\n\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos; // cursor.popState();\n        // if (\n        //   cursor.pushRightBeforeInput() &&\n        //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n        //   (!this.lazy || this.extractInput())\n        // ) return cursor.pos;\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.value.length; // backward flow\n\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"]},"metadata":{},"sourceType":"module"}