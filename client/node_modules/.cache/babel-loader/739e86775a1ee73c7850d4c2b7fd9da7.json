{"ast":null,"code":"import { _ as _createClass, a as _classCallCheck, f as _slicedToArray } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, forceDirection, DIRECTION } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n/** Supported mask type */\n\n/** Provides common masking stuff */\n\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return; // $FlowFixMe\n\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\n      Sets new options\n      @protected\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n    /** Resets value */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n    /** Resolve new value */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n    /** */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this.isComplete;\n    }\n    /** Finds nearest input position in direction */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n      var details;\n\n      var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));\n\n      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);\n\n      ch = _normalizePrepare2[0];\n      details = _normalizePrepare2[1];\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite === true) {\n            consistentTail = checkTail.state;\n            checkTail.unshift(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n            this.state = beforeTailState;\n            consistentTail = checkTail.state;\n            checkTail.shift();\n            tailDetails = this.appendTail(checkTail);\n            appended = tailDetails.rawInserted === checkTail.toString();\n          } // if ok, rollback state after tail\n\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends optional eager placeholder at end */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags && flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {\n        details.aggregate(this._appendEager());\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\n      Prepares string before mask processing\n      @protected\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\n      Validates if value is acceptable\n      @protected\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\n      Does additional processing in the end of editing\n      @protected\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var oldRawValue;\n\n      if (this.eager) {\n        removeDirection = forceDirection(removeDirection);\n        oldRawValue = this.extractInput(0, tailPos, {\n          raw: true\n        });\n      }\n\n      var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);\n      var details = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos));\n\n      if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n        if (removeDirection === DIRECTION.FORCE_LEFT) {\n          var valLength;\n\n          while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n            details.aggregate(new ChangeDetails({\n              tailShift: -1\n            })).aggregate(this.remove(valLength - 1));\n          }\n        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n          tail.unshift();\n        }\n      }\n\n      return details.aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n    }\n  }, {\n    key: \"maskEquals\",\n    value: function maskEquals(mask) {\n      return this.mask === mask;\n    }\n  }]);\n\n  return Masked;\n}();\n\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"sources":["C:/Users/yulya/Desktop/Новая папка/card/client/node_modules/imask/esm/masked/base.js"],"names":["_","_createClass","a","_classCallCheck","f","_slicedToArray","ChangeDetails","ContinuousTailDetails","isString","normalizePrepare","forceDirection","DIRECTION","IMask","Masked","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","key","value","updateOptions","keys","length","withValueRefresh","bind","get","set","state","reset","resolve","append","input","doCommit","doParse","doFormat","extractInput","raw","isComplete","nearestInputPos","cursorPos","direction","fromPos","arguments","undefined","toPos","slice","extractTail","appendTail","tail","String","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","flags","checkTail","consistentState","details","_normalizePrepare","doPrepare","_normalizePrepare2","aggregate","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","ci","tailShift","eager","remove","fn","_refreshing","rawInput","rawInputValue","ret","indexOf","runIsolated","_isolated","prepare","validate","parent","commit","format","parse","splice","start","deleteCount","removeDirection","tailPos","oldRawValue","startChangePos","NONE","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","v","default"],"mappings":"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","sourcesContent":["import { _ as _createClass, a as _classCallCheck, f as _slicedToArray } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, forceDirection, DIRECTION } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Provides common masking stuff */\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return; // $FlowFixMe\n\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\n      Sets new options\n      @protected\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n    /** Resets value */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n    /** Resolve new value */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n    /** */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this.isComplete;\n    }\n    /** Finds nearest input position in direction */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n      var details;\n\n      var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));\n\n      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);\n\n      ch = _normalizePrepare2[0];\n      details = _normalizePrepare2[1];\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite === true) {\n            consistentTail = checkTail.state;\n            checkTail.unshift(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n            this.state = beforeTailState;\n            consistentTail = checkTail.state;\n            checkTail.shift();\n            tailDetails = this.appendTail(checkTail);\n            appended = tailDetails.rawInserted === checkTail.toString();\n          } // if ok, rollback state after tail\n\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends optional eager placeholder at end */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags && flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {\n        details.aggregate(this._appendEager());\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\n      Prepares string before mask processing\n      @protected\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\n      Validates if value is acceptable\n      @protected\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\n      Does additional processing in the end of editing\n      @protected\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var oldRawValue;\n\n      if (this.eager) {\n        removeDirection = forceDirection(removeDirection);\n        oldRawValue = this.extractInput(0, tailPos, {\n          raw: true\n        });\n      }\n\n      var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);\n      var details = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos));\n\n      if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n        if (removeDirection === DIRECTION.FORCE_LEFT) {\n          var valLength;\n\n          while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n            details.aggregate(new ChangeDetails({\n              tailShift: -1\n            })).aggregate(this.remove(valLength - 1));\n          }\n        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n          tail.unshift();\n        }\n      }\n\n      return details.aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n    }\n  }, {\n    key: \"maskEquals\",\n    value: function maskEquals(mask) {\n      return this.mask === mask;\n    }\n  }]);\n\n  return Masked;\n}();\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"]},"metadata":{},"sourceType":"module"}