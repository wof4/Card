{"ast":null,"code":"import { _ as _createClass, a as _classCallCheck, b as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\nvar _excluded = [\"chunks\"];\n\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, _excluded);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport { ChunksTailDetails as default };","map":{"version":3,"sources":["C:/Users/yulya/Desktop/Новая папка/card/client/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"names":["_","_createClass","a","_classCallCheck","b","_objectWithoutProperties","ChangeDetails","isString","ContinuousTailDetails","IMask","_excluded","ChunksTailDetails","chunks","arguments","length","undefined","from","key","value","toString","map","String","join","extend","tailChunk","lastChunk","extendLast","stop","push","firstTailChunk","shift","blockIndex","appendTo","masked","MaskedPattern","tail","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","chunkBlock","index","_stops","indexOf","aggregate","_appendPlaceholder","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","get","c","state","set","props","Object","assign","cstate","unshift","beforePos","chunkShiftPos","shiftChar","splice","default"],"mappings":"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","sourcesContent":["import { _ as _createClass, a as _classCallCheck, b as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nvar _excluded = [\"chunks\"];\n\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, _excluded);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport { ChunksTailDetails as default };\n"]},"metadata":{},"sourceType":"module"}